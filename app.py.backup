import os
import uuid
import threading
from datetime import datetime
from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_socketio import SocketIO, emit

# Import TTS adapter and services
from app import tts_adapter
from app.services.heygen_service import HeyGenService
from app.services.wasabi_service import WasabiService

app = Flask(__name__)

# CRITICAL: CORS Configuration
CORS(app, resources={
    r"/*": {
        "origins": "*",
        "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization"],
        "supports_credentials": True
    }
})

# SocketIO with CORS
socketio = SocketIO(app, 
    cors_allowed_origins="*",
    async_mode='threading',
    logger=True,
    engineio_logger=True,
    ping_timeout=60,
    ping_interval=25
)

# In-memory job tracking
active_jobs = {}

@app.route('/', methods=['GET'])
def health_check():
    return jsonify({
        'status': 'healthy',
        'service': 'AI Video Engineer Backend',
        'version': '1.0.0'
    }), 200

@app.route('/health', methods=['GET'])
def health():
    return jsonify({'status': 'healthy'}), 200

def process_video(video_id, script, template, user_id):
    """Process video generation with real TTS integration"""
    try:
        # Step 1: Starting
        socketio.emit('video_status', {
            'id': video_id,
            'status': 'processing',
            'message': 'Starting video generation...',
            'progress': 10,
            'userId': user_id
        })
        
        # Step 2: Generate audio using TTS adapter (VibeVoice with ElevenLabs fallback)
        socketio.emit('video_status', {
            'id': video_id,
            'status': 'processing',
            'message': 'Generating voiceover with VibeVoice...',
            'progress': 20,
            'userId': user_id
        })
        
        audio_path = tts_adapter.generate_audio(
            text=script,
            filename_prefix=f"video_{video_id}",
            voice=None,  # Use default voice
            format="wav"  # WAV for HeyGen compatibility
        )
        
        if not audio_path:
            raise Exception("Audio generation failed with both VibeVoice and ElevenLabs")
        
        socketio.emit('video_status', {
            'id': video_id,
            'status': 'processing',
            'message': f'Audio generated: {audio_path}',
            'progress': 40,
            'userId': user_id
        })
        
        # Step 3: Upload audio to Wasabi
        socketio.emit('video_status', {
            'id': video_id,
            'status': 'processing',
            'message': 'Uploading audio to cloud storage...',
            'progress': 50,
            'userId': user_id
        })
        
        wasabi = WasabiService()
        audio_url = wasabi.upload_file(audio_path, f"audio/{video_id}.wav")
        
        if not audio_url:
            raise Exception("Failed to upload audio to Wasabi")
        
        # Step 4: Generate avatar video with HeyGen
        socketio.emit('video_status', {
            'id': video_id,
            'status': 'processing',
            'message': 'Creating avatar video with HeyGen...',
            'progress': 60,
            'userId': user_id
        })
        
        heygen = HeyGenService()
        avatar_video = heygen.create_avatar_video(
            audio_url=audio_url,
            avatar_id=template
        )
        
        if not avatar_video:
            raise Exception("HeyGen avatar video generation failed")
        
        socketio.emit('video_status', {
            'id': video_id,
            'status': 'processing',
            'message': 'Finalizing video...',
            'progress': 90,
            'userId': user_id
        })
        
        # Step 5: Upload final video to Wasabi
        final_video_url = wasabi.upload_file(avatar_video, f"videos/{video_id}.mp4")
        
        if not final_video_url:
            raise Exception("Failed to upload final video")
        
        # Cleanup temporary files
        if os.path.exists(audio_path):
            os.remove(audio_path)
        if os.path.exists(avatar_video):
            os.remove(avatar_video)
        
        # Step 6: Complete
        socketio.emit('video_status', {
            'id': video_id,
            'status': 'completed',
            'message': 'Video generation complete!',
            'progress': 100,
            'videoUrl': final_video_url,
            'userId': user_id
        })
        
        active_jobs[video_id] = {
            'status': 'completed',
            'videoUrl': final_video_url,
            'completedAt': datetime.utcnow().isoformat()
        }
        
    except Exception as e:
        error_message = str(e)
        print(f"❌ Error processing video {video_id}: {error_message}")
        
        socketio.emit('video_status', {
            'id': video_id,
            'status': 'failed',
            'message': f'Error: {error_message}',
            'progress': 0,
            'userId': user_id
        })
        
        active_jobs[video_id] = {
            'status': 'failed',
            'error': error_message,
            'failedAt': datetime.utcnow().isoformat()
        }

@app.route('/generate-video', methods=['POST', 'OPTIONS'])
def generate_video():
    if request.method == 'OPTIONS':
        return '', 204
        
    try:
        data = request.get_json()
        script = data.get('script', '').strip()
        template = data.get('template', 'presenter1')
        user_id = data.get('userId', 'anonymous')
        
        if not script:
            return jsonify({'error': 'Script is required'}), 400
        
        video_id = str(uuid.uuid4())
        
        active_jobs[video_id] = {
            'status': 'started',
            'startedAt': datetime.utcnow().isoformat()
        }
        
        thread = threading.Thread(
            target=process_video,
            args=(video_id, script, template, user_id)
        )
        thread.daemon = True
        thread.start()
        
        return jsonify({
            'id': video_id,
            'status': 'started',
            'message': 'Video generation initiated'
        }), 202
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/video-status/<video_id>', methods=['GET'])
def get_video_status(video_id):
    job = active_jobs.get(video_id)
    if not job:
        return jsonify({'error': 'Video not found'}), 404
    return jsonify(job)

# TTS Admin Endpoints
@app.route('/tts/health', methods=['GET'])
def tts_health():
    """Check TTS providers health status"""
    try:
        health_status = tts_adapter.health_check()
        return jsonify(health_status), 200
    except Exception as e:
        return jsonify({'status': 'error', 'error': str(e)}), 500

@app.route('/admin/set-tts-provider', methods=['POST', 'GET'])
def set_tts_provider():
    """
    Admin endpoint to manually set TTS provider
    GET /admin/set-tts-provider?provider=vibevoice
    POST /admin/set-tts-provider with body: {"provider": "vibevoice"}
    """
    if request.method == 'POST':
        data = request.get_json()
        provider = data.get('provider', '').lower()
    else:
        provider = request.args.get('provider', '').lower()
    
    if not provider:
        return jsonify({'error': 'provider parameter required'}), 400
    
    success = tts_adapter.set_provider(provider)
    
    if success:
        return jsonify({
            'success': True,
            'provider': provider,
            'message': f'TTS provider set to {provider}'
        }), 200
    else:
        return jsonify({
            'success': False,
            'error': 'Invalid provider. Use "vibevoice" or "elevenlabs"'
        }), 400

@socketio.on('connect')
def handle_connect():
    print('✅ Client connected')
    emit('video_status', {'message': 'Connected to AI Video Engineer backend'})

@socketio.on('disconnect')
def handle_disconnect():
    print('❌ Client disconnected')

if __name__ == '__main__':
    port = int(os.getenv('PORT', 10000))
    socketio.run(app, host='0.0.0.0', port=port, debug=False, allow_unsafe_werkzeug=True)
